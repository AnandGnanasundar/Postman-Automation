{
	"info": {
		"_postman_id": "1800612c-6800-47fd-b0a4-21d2aafcf442",
		"name": "TMF646-Appointment-External (Staging - API Automation)",
		"description": "# Description\n\nThe appointment API provides the ability to search for available time slots based on given parameters. An appointment can then be created for one of the free time slots. The buyer can query appointment availability, reserve an appointment and include the reservation id in the order request.\n\nIf this is not done, the order will go into a waiting state and will not progress, the buyer will need to reserve an appointment and then amend the order to include the appointment reservation id before the order can complete.\n\n\n**SearchTimeSlot resource**\nSearchTimeSlot API performs the following operations on SearchTimeSlot \n- Creation of a searchTimeSlot (including default values and creation rules)\n\n**Appointment resource**\nAppointment API performs the following operations on Appointment\n- Creation of an appointment (including default values and creation rules)\n\n# Documentation\n\n## https://www.cityfibre.com\n\nThe appointment API provides the ability to query available appointment slots and create / reserve an appointment with all the necessary characteristics.\n\n",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "44747098",
		"_collection_link": "https://cityfibre.postman.co/workspace/TMF-Test~c4a64f74-2155-4fc7-9e89-57c84cff031a/collection/44747098-1800612c-6800-47fd-b0a4-21d2aafcf442?action=share&source=collection_link&creator=44747098"
	},
	"item": [
		{
			"name": "API Automation",
			"item": [
				{
					"name": "searchTimeSlot",
					"item": [
						{
							"name": "Valid_Requests",
							"item": [
								{
									"name": "LeadTimeValidation",
									"item": [
										{
											"name": "OrderTypes_LeadTime",
											"item": [
												{
													"name": "CreateSearchTimeSlot_SwitchOrderType_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 2 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 2);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 2 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"orderType\": \"Switch\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"5880000029\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"5880000029\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_WLTO_DifferentISP_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 10 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 10);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 10 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"orderType\": \"WLTO\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"5880000029\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"5880000029\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_WLTO_SameISP_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 2 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 2);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 2 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"orderType\": \"WLTO\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"5880000035\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"5880000035\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_RegradeOrderType_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 2 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 2);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 2 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"orderType\": \"Regrade\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"5880000035\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"5880000035\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												}
											]
										},
										{
											"name": "Business_LeadTime",
											"item": [
												{
													"name": "CreateSearchTimeSlot_Business_RFS1_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 20 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 20);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 20 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"2025-05-24T12:42:55.481Z\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"6237273263\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"6237273263\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2b\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_Business_RFS2_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 10 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 10);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 10 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311051\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311051\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2b\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_Business_RFS2_Reappointment_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 2 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 2);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 2 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311051\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311051\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2b\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_Business_RFS1_Reappointment_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 10 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 10);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 10 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"6237273263\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"6237273263\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2b\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												}
											]
										},
										{
											"name": "PropertyFlag_LeadTime",
											"item": [
												{
													"name": "CreateSearchTimeSlot_WSOD_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        addedDays++;",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 30 calendar days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 30);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 30 calendar days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311072\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311072\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_MOD_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        addedDays++;",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 60 calendar days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 60);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 60 calendar days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311071\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311071\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_IN_EAD_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 20 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 20);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 20 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311069\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311069\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_IN_PIAUG_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 10 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 10);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 10 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311068\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311068\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_SUR_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 10 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 10);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 10 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"10090357414\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"10090357414\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_MDU_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 10 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 10);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 10 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"25104498\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"25104498\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_DTL_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = moment(date).format('YYYY-MM-DD'); // Use moment formatting",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = moment(startDate).startOf('day');",
																	"    console.log(`Start date: ${currentDate.format('YYYY-MM-DD')}`);",
																	"",
																	"    currentDate.add(days, 'days');",
																	"    console.log(`After adding ${days} calendar days: ${currentDate.format('YYYY-MM-DD')}`);",
																	"",
																	"    while (currentDate.day() === 0 || currentDate.day() === 6 || isBankHoliday(currentDate)) {",
																	"        console.log(`Adjusting for weekend/holiday: ${currentDate.format('YYYY-MM-DD')}`);",
																	"        currentDate.add(1, 'days');",
																	"    }",
																	"",
																	"    console.log(`Final date: ${currentDate.format('YYYY-MM-DD')}`);",
																	"    return currentDate.format('YYYY-MM-DD');",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;    ",
																	"    ",
																	"// Validate that the first available time slot is at least 14 calendar days from today",
																	"const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"const firstAvailableMoment = moment.utc(firstAvailableSlot).startOf('day');",
																	"const expectedMoment = moment.utc().startOf('day').add(14, 'days');",
																	"const allowedEarlyDate = expectedMoment.clone().subtract(1, 'day');",
																	"",
																	"pm.test(\"First available time slot is at least 13 calendar days from today\", () => {",
																	"    pm.expect(firstAvailableMoment.isBetween(allowedEarlyDate, moment.utc().add(1, 'year'), null, '[]')).to.be.true;",
																	"});",
																	"})"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"10093789534\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"10093789534\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_WSD_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = moment(date).format('YYYY-MM-DD'); // Use moment formatting",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = moment(startDate).startOf('day');",
																	"    console.log(`Start date: ${currentDate.format('YYYY-MM-DD')}`);",
																	"",
																	"    currentDate.add(days, 'days');",
																	"    console.log(`After adding ${days} calendar days: ${currentDate.format('YYYY-MM-DD')}`);",
																	"",
																	"    while (currentDate.day() === 0 || currentDate.day() === 6 || isBankHoliday(currentDate)) {",
																	"        console.log(`Adjusting for weekend/holiday: ${currentDate.format('YYYY-MM-DD')}`);",
																	"        currentDate.add(1, 'days');",
																	"    }",
																	"",
																	"    console.log(`Final date: ${currentDate.format('YYYY-MM-DD')}`);",
																	"    return currentDate.format('YYYY-MM-DD');",
																	"}",
																	"",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"// Validate that the first available time slot is at least 14 calendar days from today",
																	"const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"const firstAvailableMoment = moment.utc(firstAvailableSlot).startOf('day');",
																	"const expectedMoment = moment.utc().startOf('day').add(14, 'days');",
																	"const allowedEarlyDate = expectedMoment.clone().subtract(1, 'day');",
																	"",
																	"pm.test(\"First available time slot is at least 13 calendar days from today\", () => {",
																	"    pm.expect(firstAvailableMoment.isBetween(allowedEarlyDate, moment.utc().add(1, 'year'), null, '[]')).to.be.true;",
																	"});",
																	"})"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"25046912\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"25046912\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_OD60_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        addedDays++;",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 60 calendar days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 60);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 60 calendar days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311066\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311066\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												}
											]
										},
										{
											"name": "NetworkReadiness_LeadTime",
											"item": [
												{
													"name": "CreateSearchTimeSlot_Standard_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 5 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 5);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 5 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311067\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311067\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_ExtendedStandard_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 10 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 10);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 10 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311067\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311065\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												},
												{
													"name": "CreateSearchTimeSlot_NonStandard_Property_request",
													"event": [
														{
															"listen": "test",
															"script": {
																"exec": [
																	"// --------------------------------------------------------------------------------",
																	"// Variables",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"const responseBody = pm.response.json();",
																	"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
																	"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
																	"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
																	"const baseUrl = getVariable(\"baseUrl\");",
																	"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
																	"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
																	"const Ajv = require('ajv');",
																	"const ajv = new Ajv();",
																	"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
																	"var moment = require('moment');",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Functions",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"function getVariable(varName) {",
																	"    let varValue;",
																	"",
																	"    if (pm.environment.has(varName)) {",
																	"        varValue = pm.environment.get(varName);",
																	"    } else if (pm.collectionVariables.has(varName)) {",
																	"        varValue = pm.collectionVariables.get(varName);",
																	"    } else {",
																	"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"        return;",
																	"    }",
																	"",
																	"    return varValue;",
																	"}",
																	"",
																	"function parseJson(jsonStr, errorMessage) {",
																	"    try {",
																	"        return JSON.parse(jsonStr);",
																	"    } catch (e) {",
																	"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
																	"        console.error(\"Raw response body:\", jsonStr);",
																	"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
																	"        return null;",
																	"    }",
																	"}",
																	"",
																	"function validateNotEmpty(value, errorMessage) {",
																	"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
																	"    if (Array.isArray(value)) {",
																	"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
																	"        value.forEach((item, index) => {",
																	"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else if (typeof value === 'object') {",
																	"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
																	"        Object.keys(value).forEach((key) => {",
																	"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
																	"        });",
																	"    } else {",
																	"        pm.expect(value).to.not.be.empty;",
																	"    }",
																	"}",
																	"",
																	"function validateResponseBody(responseBody) {",
																	"    try {",
																	"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
																	"    } catch (e) {",
																	"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function validateSchema(schemaJson, parsedBody) {",
																	"    try {",
																	"        const validate = ajv.compile(schemaJson);",
																	"        pm.expect(validate(parsedBody)).to.be.true;",
																	"    } catch (e) {",
																	"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
																	"        pm.expect(false, errorMsg).to.be.true;",
																	"        console.error(errorMsg);",
																	"    }",
																	"}",
																	"",
																	"function verifyEachField(actual, expected, path = '', context = {}) {",
																	"    for (const key in actual) {",
																	"        if (actual.hasOwnProperty(key)) {",
																	"            const currentPath = path ? `${path}.${key}` : key;",
																	"            try {",
																	"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
																	"                    verifyEachField(actual[key], expected[key], currentPath, context);",
																	"                } else {",
																	"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
																	"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
																	"                }",
																	"            } catch (e) {",
																	"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
																	"                pm.expect(false, errorMsg).to.be.true;",
																	"                console.error(errorMsg);",
																	"            }",
																	"        }",
																	"    }",
																	"}",
																	"",
																	"// Function to check if a date is a bank holiday",
																	"function isBankHoliday(date) {",
																	"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
																	"    return bankHolidays.includes(dateString);",
																	"}",
																	"",
																	"// Function to calculate the date after a specified number of working days",
																	"function addWorkingDays(startDate, days) {",
																	"    let currentDate = new Date(startDate);",
																	"    let addedDays = 0;",
																	"",
																	"    while (addedDays < days) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
																	"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
																	"            addedDays++;",
																	"        }",
																	"    }",
																	"    // If the resulting date falls on a holiday or weekend, adjust it",
																	"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
																	"        currentDate.setDate(currentDate.getDate() + 1);",
																	"    }",
																	"",
																	"    return moment(currentDate).format('YYYY-MM-DD');;",
																	"}",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Request",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
																	"",
																	"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
																	"",
																	"pm.test(\"Authorization Header Validation\", () =>",
																	"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
																	");",
																	"",
																	"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
																	"",
																	"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
																	"",
																	"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
																	"",
																	"// --------------------------------------------------------------------------------",
																	"// Tests for the Response",
																	"// --------------------------------------------------------------------------------",
																	"",
																	"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
																	"",
																	"pm.test(\"Response Content-Type Validation\", () =>",
																	"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
																	");",
																	"",
																	"pm.test(\"Response Body Validation\", () => {",
																	"    try {",
																	"        validateResponseBody(responseBody);",
																	"    } catch (e) {",
																	"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
																	"        console.error(\"Raw response body:\", pm.response.body);",
																	"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
																	"    }",
																	"});",
																	"",
																	"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
																	"",
																	"pm.test(\"Response should have correct @type\", () => {",
																	"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedPlace\", () => {",
																	"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
																	"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchResult\", () => {",
																	"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
																	"});",
																	"",
																	"pm.test(\"Response should have correct relatedEntity\", () => {",
																	"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
																	"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct searchDate\", () => {",
																	"    const currentDate = new Date().toISOString().slice(0, 16);",
																	"    pm.expect(responseBody.searchDate).to.include(currentDate);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
																	"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
																	"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
																	"});",
																	"",
																	"pm.test(\"Response should have correct availableTimeSlot\", () => {",
																	"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
																	"",
																	"    // Validate that the first available time slot is at least 10 working days from today",
																	"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
																	"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
																	"",
																	"    const today = new Date();",
																	"    const expectedDate = addWorkingDays(today, 10);",
																	"    console.log(expectedDate);",
																	"    console.log(firstAvailableStartDateTime);",
																	"",
																	"    pm.test(\"First available time slot is at least 10 working days from today\", function() {",
																	"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
																	"    });",
																	"",
																	"});"
																],
																"type": "text/javascript",
																"packages": {}
															}
														},
														{
															"listen": "prerequest",
															"script": {
																"exec": [
																	""
																],
																"type": "text/javascript",
																"packages": {}
															}
														}
													],
													"request": {
														"method": "POST",
														"header": [],
														"body": {
															"mode": "raw",
															"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311064\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311064\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
															"options": {
																"raw": {
																	"language": "json"
																}
															}
														},
														"url": {
															"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
															"host": [
																"{{baseUrl}}"
															],
															"path": [
																"tmf-api",
																"v5",
																"appointmentManagement",
																"v1",
																"searchTimeSlot"
															],
															"query": [
																{
																	"key": "Fields",
																	"value": "id,name"
																}
															]
														}
													},
													"response": []
												}
											]
										}
									]
								},
								{
									"name": "CreateSearchTimeSlot_request",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function verifyEachField(actual, expected, path = '', context = {}) {",
													"    for (const key in actual) {",
													"        if (actual.hasOwnProperty(key)) {",
													"            const currentPath = path ? `${path}.${key}` : key;",
													"            try {",
													"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
													"                    verifyEachField(actual[key], expected[key], currentPath, context);",
													"                } else {",
													"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
													"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
													"                }",
													"            } catch (e) {",
													"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
													"                pm.expect(false, errorMsg).to.be.true;",
													"                console.error(errorMsg);",
													"            }",
													"        }",
													"    }",
													"}",
													"",
													"function validateAvailableTimeSlot(value, requestedDate, errorMessage){",
													"    pm.expect(value).to.not.be.undefined.and.to.not.be.null;",
													"    if (pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0)) {",
													"        value.forEach((item) => { for(const key in item) {",
													"            if (typeof item[key] == \"object\") {",
													"                Object.keys(item[key]).forEach((timeStampKey) => {",
													"                    const availableDate = new Date(item[key][timeStampKey]);",
													"                    pm.expect(item[key][timeStampKey]).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$/);",
													"                    pm.expect(availableDate.getTime()).to.be.above(requestedDate.getTime())",
													"                });",
													"            }else{",
													"                pm.expect(item).to.have.property('@type','TimeSlot');",
													"            }",
													"        }});",
													"    }           ",
													"}",
													"",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
													"",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
													"",
													"pm.test(\"Response should have correct @type\", () => {",
													"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedPlace\", () => {",
													"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
													"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
													"});",
													"",
													"pm.test(\"Response should have correct searchResult\", () => {",
													"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
													"});",
													"",
													"pm.test(\"Response should have correct relatedEntity\", () => {",
													"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
													"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
													"});",
													"",
													"pm.test(\"Response should have correct searchDate\", () => {",
													"    const currentDate = new Date().toISOString().slice(0, 16);",
													"    pm.expect(responseBody.searchDate).to.include(currentDate);",
													"});",
													"",
													"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
													"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
													"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
													"});",
													"",
													"pm.test(\"Response should have correct availableTimeSlot\", () => {",
													"    requestedTime = new Date(requestBody.requestedTimeSlot[0]['validFor']['startDateTime'])",
													"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
													"    validateAvailableTimeSlot(responseBody.availableTimeSlot, requestedTime, 'Available Time Slot is empty');",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n    \"@type\": \"SearchTimeSlot\",\n    \"requestedTimeSlot\": [\n        {\n            \"validFor\": {\n                \"startDateTime\": \"2025-03-27T13:00:00.000Z\"\n            },\n            \"@type\": \"TimeSlot\"\n        }\n    ],\n    \"relatedParty\": {\n        \"role\": \"buyer\",\n        \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n        \"partyOrPartyRole\": {\n            \"id\": \"TEST\",\n            \"name\": \"TEST\",\n            \"@type\": \"PartyRef\",\n            \"@referredType\": \"Organisation\"\n        }\n    },\n    \"appointmentType\": \"order\",\n    \"ispMigration\": true,\n    \"reappointment\": false,\n    \"relatedPlace\": {\n        \"role\": \"install location\",\n        \"@type\": \"RelatedPlaceRef\",\n        \"place\": {\n            \"id\": \"5880000020\",\n            \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddressManagement/v1/geographicAddress/5880000020\",\n            \"name\": \"end user's address\",\n            \"externalIdentifier\": [\n                {\n                    \"id\": \"5880000020\",\n                    \"externalIdentifierType\": \"UPRN\",\n                    \"@type\": \"ExternalIdentifier\"\n                }\n            ],\n            \"@type\": \"PlaceRef\",\n            \"@referredType\": \"GeographicAddress\"\n        }\n    },\n    \"relatedEntity\": [\n        {\n            \"role\": \"Product\",\n            \"@type\": \"RelatedEntity\",\n            \"entity\": {\n                \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n                \"name\": \"ftthl2r\",\n                \"@type\": \"EntityRef\",\n                \"@referredType\": \"ProductRef\"\n            }\n        }\n    ]\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"searchTimeSlot"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "CreateSearchTimeSlot_ISPMigration_LeadTime",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
													"var moment = require('moment');",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function verifyEachField(actual, expected, path = '', context = {}) {",
													"    for (const key in actual) {",
													"        if (actual.hasOwnProperty(key)) {",
													"            const currentPath = path ? `${path}.${key}` : key;",
													"            try {",
													"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
													"                    verifyEachField(actual[key], expected[key], currentPath, context);",
													"                } else {",
													"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
													"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
													"                }",
													"            } catch (e) {",
													"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
													"                pm.expect(false, errorMsg).to.be.true;",
													"                console.error(errorMsg);",
													"            }",
													"        }",
													"    }",
													"}",
													"",
													"// Function to check if a date is a bank holiday",
													"function isBankHoliday(date) {",
													"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
													"    return bankHolidays.includes(dateString);",
													"}",
													"",
													"// Function to calculate the date after a specified number of working days",
													"function addWorkingDays(startDate, days) {",
													"    let currentDate = new Date(startDate);",
													"    let addedDays = 0;",
													"",
													"    while (addedDays < days) {",
													"        currentDate.setDate(currentDate.getDate() + 1);",
													"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
													"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
													"            addedDays++;",
													"        }",
													"    }",
													"    // If the resulting date falls on a holiday or weekend, adjust it",
													"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
													"        currentDate.setDate(currentDate.getDate() + 1);",
													"    }",
													"",
													"    return moment(currentDate).format('YYYY-MM-DD');;",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
													"",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
													"",
													"pm.test(\"Response should have correct @type\", () => {",
													"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedPlace\", () => {",
													"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
													"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
													"});",
													"",
													"pm.test(\"Response should have correct searchResult\", () => {",
													"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
													"});",
													"",
													"pm.test(\"Response should have correct relatedEntity\", () => {",
													"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
													"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
													"});",
													"",
													"pm.test(\"Response should have correct searchDate\", () => {",
													"    const currentDate = new Date().toISOString().slice(0, 16);",
													"    pm.expect(responseBody.searchDate).to.include(currentDate);",
													"});",
													"",
													"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
													"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
													"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
													"});",
													"",
													"pm.test(\"Response should have correct availableTimeSlot\", () => {",
													"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
													"",
													"    // Validate that the first available time slot is at least 10 working days from today",
													"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
													"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
													"",
													"    const today = new Date();",
													"    const expectedDate = addWorkingDays(today, 2);",
													"    console.log(expectedDate);",
													"    console.log(firstAvailableStartDateTime);",
													"",
													"    pm.test(\"First available time slot is at least 2 working days from today\", function() {",
													"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
													"    });",
													"",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": true,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"searchTimeSlot"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "CreateSearchTimeSlot_ISPMigration_Reappointment_LeadTime",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaSearchTimeSlot\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"let bankHolidays = JSON.parse(pm.environment.get(\"bankHolidays\"));",
													"var moment = require('moment');",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function verifyEachField(actual, expected, path = '', context = {}) {",
													"    for (const key in actual) {",
													"        if (actual.hasOwnProperty(key)) {",
													"            const currentPath = path ? `${path}.${key}` : key;",
													"            try {",
													"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
													"                    verifyEachField(actual[key], expected[key], currentPath, context);",
													"                } else {",
													"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
													"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
													"                }",
													"            } catch (e) {",
													"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
													"                pm.expect(false, errorMsg).to.be.true;",
													"                console.error(errorMsg);",
													"            }",
													"        }",
													"    }",
													"}",
													"",
													"// Function to check if a date is a bank holiday",
													"function isBankHoliday(date) {",
													"    const dateString = date.toISOString().split('T')[0]; // Format date to YYYY-MM-DD",
													"    return bankHolidays.includes(dateString);",
													"}",
													"",
													"// Function to calculate the date after a specified number of working days",
													"function addWorkingDays(startDate, days) {",
													"    let currentDate = new Date(startDate);",
													"    let addedDays = 0;",
													"",
													"    while (addedDays < days) {",
													"        currentDate.setDate(currentDate.getDate() + 1);",
													"        // Check if it's a weekend (Saturday or Sunday) or a bank holiday",
													"        if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6 && !isBankHoliday(currentDate)) {",
													"            addedDays++;",
													"        }",
													"    }",
													"    // If the resulting date falls on a holiday or weekend, adjust it",
													"    while (isBankHoliday(currentDate) || currentDate.getDay() === 0 || currentDate.getDay() === 6) {",
													"        currentDate.setDate(currentDate.getDate() + 1);",
													"    }",
													"",
													"    return moment(currentDate).format('YYYY-MM-DD');;",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(200));",
													"",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
													"",
													"pm.test(\"Response should have correct @type\", () => {",
													"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedPlace\", () => {",
													"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
													"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
													"});",
													"",
													"pm.test(\"Response should have correct searchResult\", () => {",
													"    pm.expect(responseBody.searchResult).to.eql(\"success\");",
													"});",
													"",
													"pm.test(\"Response should have correct relatedEntity\", () => {",
													"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
													"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
													"});",
													"",
													"pm.test(\"Response should have correct searchDate\", () => {",
													"    const currentDate = new Date().toISOString().slice(0, 16);",
													"    pm.expect(responseBody.searchDate).to.include(currentDate);",
													"});",
													"",
													"pm.test(\"Response should have correct requestedTimeSlot\", () => {",
													"    pm.expect(responseBody.requestedTimeSlot).to.be.an('array').that.has.lengthOf(requestBody.requestedTimeSlot.length);",
													"    verifyEachField(requestBody.requestedTimeSlot, responseBody.requestedTimeSlot);",
													"});",
													"",
													"pm.test(\"Response should have correct availableTimeSlot\", () => {",
													"    pm.expect(responseBody.availableTimeSlot).to.be.an('array').that.is.not.empty;",
													"",
													"    // Validate that the first available time slot is at least 2 working days from today",
													"    const firstAvailableSlot = responseBody.availableTimeSlot[0].validFor.startDateTime;",
													"    const firstAvailableStartDateTime = (moment(firstAvailableSlot)).format('YYYY-MM-DD');",
													"",
													"    const today = new Date();",
													"    const expectedDate = addWorkingDays(today, 2);",
													"    console.log(expectedDate);",
													"    console.log(firstAvailableStartDateTime);",
													"",
													"    pm.test(\"First available time slot is at least 2 working days from today\", function() {",
													"        pm.expect(firstAvailableStartDateTime).to.eql(expectedDate);",
													"    });",
													"",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": true,\n  \"reappointment\": true,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"searchTimeSlot"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "Invalid_Requests",
							"item": [
								{
									"name": "CreateSearchTimeSlot_400_BadRequest",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaBadRequest\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(400));",
													"",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TEST\",\n      \"name\": \"TEST\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"null\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"searchTimeSlot"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "CreateSearchTimeSlot_403_Forbidden",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaBadRequest\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(403));",
													"",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TALKTALK_API\",\n      \"name\": \"TALKTALK_API\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"searchTimeSlot"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "CreateSearchTimeSlot_401_Unauthorized",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaSearchTimeSlot\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaBadRequest\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(401));",
													"",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response should have correct error message\", () => {",
													"    const expectedResponse = { error: \"Invalid token.\" };",
													"    pm.expect(responseBody).to.eql(expectedResponse);",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "jabdibaiudbqwygdbuqbwdqbwduqb",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"SearchTimeSlot\",\n  \"requestedTimeSlot\": [\n    {\n      \"validFor\": {\n        \"startDateTime\": \"{{currentStartDateTime}}\"\n      },\n      \"@type\": \"TimeSlot\"\n    }\n  ],\n  \"relatedParty\": {\n    \"role\": \"buyer\",\n    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n    \"partyOrPartyRole\": {\n      \"id\": \"TALKTALK_API\",\n      \"name\": \"TALKTALK_API\",\n      \"@type\": \"PartyRef\",\n      \"@referredType\": \"Organisation\"\n    }\n  },\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  },\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ]\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"searchTimeSlot"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								}
							]
						}
					]
				},
				{
					"name": "appointment",
					"item": [
						{
							"name": "Valid_Requests",
							"item": [
								{
									"name": "CreateAppointment_request",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaAppointmentRequest\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaAppointmentRequest\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function verifyEachField(actual, expected, path = '', context = {}) {",
													"    for (const key in actual) {",
													"        if (actual.hasOwnProperty(key)) {",
													"            const currentPath = path ? `${path}.${key}` : key;",
													"            try {",
													"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
													"                    verifyEachField(actual[key], expected[key], currentPath, context);",
													"                } else {",
													"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
													"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
													"                }",
													"            } catch (e) {",
													"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
													"                pm.expect(false, errorMsg).to.be.true;",
													"                console.error(errorMsg);",
													"            }",
													"        }",
													"    }",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(201));",
													"    ",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
													"",
													"pm.test(\"Response should have correct @type\", () => {",
													"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedPlace\", () => {",
													"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
													"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
													"});",
													"",
													"pm.test(\"Response should have correct appointmentType\", () => {",
													"    pm.expect(responseBody.appointmentType).to.eql(requestBody.appointmentType);",
													"});",
													"",
													"pm.test(\"Response should have correct validFor\", () => {",
													"    verifyEachField(requestBody.validFor, responseBody.validFor);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedEntity\", () => {",
													"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
													"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
													"});",
													"",
													"pm.test(\"Response should have correct reappointment\", () => {",
													"    pm.expect(responseBody.reappointment).to.eql(requestBody.reappointment);",
													"});",
													"",
													"pm.test(\"Response should have correct description\", () => {",
													"    pm.expect(responseBody.description).to.eql(requestBody.description);",
													"});",
													"",
													"pm.test(\"Response should have correct externalId\", () => {",
													"    pm.expect(responseBody.externalId).to.eql(requestBody.externalId);",
													"});",
													"",
													"pm.test(\"Response should have correct ispMigration\", () => {",
													"    pm.expect(responseBody.ispMigration).to.eql(requestBody.ispMigration);",
													"});",
													"",
													"pm.test(\"Response should have correct creationDate\", () => {",
													"    const currentDate = new Date().toISOString().slice(0, 16);",
													"    pm.expect(responseBody.creationDate).to.include(currentDate);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedParty\", () => {",
													"    pm.expect(responseBody.relatedParty).to.be.an('array').that.has.lengthOf(requestBody.relatedParty.length);",
													"    verifyEachField(requestBody.relatedParty, responseBody.relatedParty);",
													"});",
													"",
													"pm.test(\"Response should have correct category\", () => {",
													"    pm.expect(responseBody.category).to.eql(requestBody.category);",
													"});",
													"",
													"pm.test(\"Response should have correct id and status\", () => {",
													"    pm.expect(responseBody.id).to.match(/^[A-Z0-9]{32}$/);",
													"    pm.expect(responseBody.status).to.eql(\"initialized\");",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"Appointment\",\n  \"category\": \"New Install Order\",\n  \"description\": \"Support new install Order for a customer\",\n  \"validFor\": {\n    \"startDateTime\": \"{{firstAvailableStartDateTime}}\",\n    \"endDateTime\": \"{{firstAvailableEndDateTime}}\"\n  },\n  \"externalId\": [\n    {\n      \"@type\": \"ExternalIdentifier\",\n      \"owner\": \"ProjectManagementPlatform\",\n      \"externalIdentifierType\": \"ProjectReferenceId\",\n      \"id\": \"\"\n    }\n  ],\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ],\n  \"relatedParty\": [\n    {\n      \"role\": \"buyer\",\n      \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n      \"partyOrPartyRole\": {\n        \"id\": \"TEST\",\n        \"name\": \"TEST\",\n        \"@type\": \"PartyRef\",\n        \"@referredType\": \"Organisation\"\n      }\n    }\n  ],\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  }\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"appointment"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "CreateAppointment_WithOrderType_request",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaAppointmentRequest\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaAppointmentRequest\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function verifyEachField(actual, expected, path = '', context = {}) {",
													"    for (const key in actual) {",
													"        if (actual.hasOwnProperty(key)) {",
													"            const currentPath = path ? `${path}.${key}` : key;",
													"            try {",
													"                if (typeof actual[key] === 'object' && actual[key] !== null && typeof expected[key] === 'object' && expected[key] !== null) {",
													"                    verifyEachField(actual[key], expected[key], currentPath, context);",
													"                } else {",
													"                    const errorMsgValue = `Value mismatch at ${currentPath}`;",
													"                    pm.expect(actual[key], errorMsgValue).to.eql(expected[key]);",
													"                }",
													"            } catch (e) {",
													"                const errorMsg = `Json compare failed at ${currentPath}: ${e.message}`;",
													"                pm.expect(false, errorMsg).to.be.true;",
													"                console.error(errorMsg);",
													"            }",
													"        }",
													"    }",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(201));",
													"    ",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
													"",
													"pm.test(\"Response should have correct @type\", () => {",
													"    pm.expect(responseBody[\"@type\"]).to.eql(requestBody[\"@type\"]);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedPlace\", () => {",
													"    pm.expect(responseBody.relatedPlace).to.be.an('object').that.is.not.empty;",
													"    verifyEachField(requestBody.relatedPlace, responseBody.relatedPlace);",
													"});",
													"",
													"pm.test(\"Response should have correct appointmentType\", () => {",
													"    pm.expect(responseBody.appointmentType).to.eql(requestBody.appointmentType);",
													"});",
													"",
													"pm.test(\"Response should have correct validFor\", () => {",
													"    verifyEachField(requestBody.validFor, responseBody.validFor);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedEntity\", () => {",
													"    pm.expect(responseBody.relatedEntity).to.be.an('array').that.has.lengthOf(requestBody.relatedEntity.length);",
													"    verifyEachField(requestBody.relatedEntity, responseBody.relatedEntity);",
													"});",
													"",
													"pm.test(\"Response should have correct reappointment\", () => {",
													"    pm.expect(responseBody.reappointment).to.eql(requestBody.reappointment);",
													"});",
													"",
													"pm.test(\"Response should have correct description\", () => {",
													"    pm.expect(responseBody.description).to.eql(requestBody.description);",
													"});",
													"",
													"pm.test(\"Response should have correct externalId\", () => {",
													"    pm.expect(responseBody.externalId).to.eql(requestBody.externalId);",
													"});",
													"",
													"pm.test(\"Response should have correct ispMigration\", () => {",
													"    pm.expect(responseBody.ispMigration).to.eql(requestBody.ispMigration);",
													"});",
													"",
													"pm.test(\"Response should have correct creationDate\", () => {",
													"    const currentDate = new Date().toISOString().slice(0, 16);",
													"    pm.expect(responseBody.creationDate).to.include(currentDate);",
													"});",
													"",
													"pm.test(\"Response should have correct relatedParty\", () => {",
													"    pm.expect(responseBody.relatedParty).to.be.an('array').that.has.lengthOf(requestBody.relatedParty.length);",
													"    verifyEachField(requestBody.relatedParty, responseBody.relatedParty);",
													"});",
													"",
													"pm.test(\"Response should have correct category\", () => {",
													"    pm.expect(responseBody.category).to.eql(requestBody.category);",
													"});",
													"",
													"pm.test(\"Response should have correct id and status\", () => {",
													"    pm.expect(responseBody.id).to.match(/^[A-Z0-9]{32}$/);",
													"    pm.expect(responseBody.status).to.eql(\"initialized\");",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"Appointment\",\n  \"category\": \"New Install Order\",\n  \"description\": \"Support new install Order for a customer\",\n  \"orderType\": \"Switch\",\n  \"validFor\": {\n    \"startDateTime\": \"{{firstAvailableStartDateTime}}\",\n    \"endDateTime\": \"{{firstAvailableEndDateTime}}\"\n  },\n  \"externalId\": [\n    {\n      \"@type\": \"ExternalIdentifier\",\n      \"owner\": \"ProjectManagementPlatform\",\n      \"externalIdentifierType\": \"ProjectReferenceId\",\n      \"id\": \"\"\n    }\n  ],\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ],\n  \"relatedParty\": [\n    {\n      \"role\": \"buyer\",\n      \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n      \"partyOrPartyRole\": {\n        \"id\": \"TEST\",\n        \"name\": \"TEST\",\n        \"@type\": \"PartyRef\",\n        \"@referredType\": \"Organisation\"\n      }\n    }\n  ],\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  }\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"appointment"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "Invalid_Requests",
							"item": [
								{
									"name": "CreateAppointment_400_BadRequest",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaAppointmentRequest\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaBadRequest\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(400));",
													"    ",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
													"",
													"pm.test(\"Response should have correct @type\", () => {",
													"    pm.expect(responseBody[\"@type\"]).to.eql(\"Error\");",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"Appointment\",\n  \"category\": \"New Install Order\",\n  \"description\": \"Support new install Order for a customer\",\n  \"validFor\": {\n    \"startDateTime\": \"{{firstAvailableStartDateTime}}\",\n    \"endDateTime\": \"{{firstAvailableEndDateTime}}\"\n  },\n  \"externalId\": [\n    {\n      \"@type\": \"ExternalIdentifier\",\n      \"owner\": \"ProjectManagementPlatform\",\n      \"externalIdentifierType\": \"ProjectReferenceId\",\n      \"id\": \"\"\n    }\n  ],\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ],\n  \"relatedParty\": [\n    {\n      \"role\": \"buyer\",\n      \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n      \"partyOrPartyRole\": {\n        \"id\": \"TEST\",\n        \"name\": \"TEST\",\n        \"@type\": \"PartyRef\",\n        \"@referredType\": \"Organisation\"\n      }\n    }\n  ],\n  \"appointmentType\": \"\",\n  \"ispMigration\": true,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  }\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"appointment"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "CreateAppointment_403_Forbidden",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaAppointmentRequest\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaBadRequest\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(403));",
													"    ",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response Body Schema Validation\", () => validateSchema(responseSchema, responseBody));",
													"",
													"pm.test(\"Response should have correct @type\", () => {",
													"    pm.expect(responseBody[\"@type\"]).to.eql(\"Error\");",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"Appointment\",\n  \"category\": \"New Install Order\",\n  \"description\": \"Support new install Order for a customer\",\n  \"validFor\": {\n    \"startDateTime\": \"{{firstAvailableStartDateTime}}\",\n    \"endDateTime\": \"{{firstAvailableEndDateTime}}\"\n  },\n  \"externalId\": [\n    {\n      \"@type\": \"ExternalIdentifier\",\n      \"owner\": \"ProjectManagementPlatform\",\n      \"externalIdentifierType\": \"ProjectReferenceId\",\n      \"id\": \"\"\n    }\n  ],\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ],\n  \"relatedParty\": [\n    {\n      \"role\": \"buyer\",\n      \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n      \"partyOrPartyRole\": {\n        \"id\": \"API_TEST\",\n        \"name\": \"API_TEST\",\n        \"@type\": \"PartyRef\",\n        \"@referredType\": \"Organisation\"\n      }\n    }\n  ],\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  }\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"appointment"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "CreateAppointment_401_Unauthorized",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"// --------------------------------------------------------------------------------",
													"// Variables",
													"// --------------------------------------------------------------------------------",
													"",
													"const responseBody = pm.response.json();",
													"const requestBody = parseJson(pm.request.body.raw, \"Request body is not valid JSON.\");",
													"const requestSchema = parseJson(getVariable(\"requestSchemaAppointmentRequest\"));",
													"const responseSchema = parseJson(getVariable(\"responseSchemaBadRequest\"));",
													"const baseUrl = getVariable(\"baseUrl\");",
													"const expectedUrl = `${baseUrl}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name`;",
													"const authorizationHeader = pm.request.headers.get(\"Authorization\");",
													"const Ajv = require('ajv');",
													"const ajv = new Ajv();",
													"",
													"// --------------------------------------------------------------------------------",
													"// Functions",
													"// --------------------------------------------------------------------------------",
													"",
													"function getVariable(varName) {",
													"    let varValue;",
													"",
													"    if (pm.environment.has(varName)) {",
													"        varValue = pm.environment.get(varName);",
													"    } else if (pm.collectionVariables.has(varName)) {",
													"        varValue = pm.collectionVariables.get(varName);",
													"    } else {",
													"        const errorMsg = `Variable \"${varName}\" not found in environment or collection!`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"        return;",
													"    }",
													"",
													"    return varValue;",
													"}",
													"",
													"function parseJson(jsonStr, errorMessage) {",
													"    try {",
													"        return JSON.parse(jsonStr);",
													"    } catch (e) {",
													"        console.error(`${errorMessage}: Unable to parse JSON`, e.message, e.stack);",
													"        console.error(\"Raw response body:\", jsonStr);",
													"        pm.expect(false, `${errorMessage}: Unable to parse JSON. Error: ${e.message}`).to.be.true;",
													"        return null;",
													"    }",
													"}",
													"",
													"function validateNotEmpty(value, errorMessage) {",
													"    pm.expect(value, errorMessage).to.not.be.undefined.and.to.not.be.null;",
													"    if (Array.isArray(value)) {",
													"        pm.expect(value.length, `${errorMessage}: Array is empty`).to.be.greaterThan(0);",
													"        value.forEach((item, index) => {",
													"            pm.expect(item, `${errorMessage}: Array element at index ${index} is invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else if (typeof value === 'object') {",
													"        pm.expect(Object.keys(value).length, `${errorMessage}: Object is empty`).to.be.greaterThan(0);",
													"        Object.keys(value).forEach((key) => {",
													"            pm.expect(value[key], `${errorMessage}: Property '${key}' is missing or invalid`).to.not.be.undefined.and.to.not.be.null;",
													"        });",
													"    } else {",
													"        pm.expect(value).to.not.be.empty;",
													"    }",
													"}",
													"",
													"function validateResponseBody(responseBody) {",
													"    try {",
													"        validateNotEmpty(responseBody, \"Response body is empty or malformed\");",
													"    } catch (e) {",
													"        const errorMsg = `Response body is not valid JSON. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"function validateSchema(schemaJson, parsedBody) {",
													"    try {",
													"        const validate = ajv.compile(schemaJson);",
													"        pm.expect(validate(parsedBody)).to.be.true;",
													"    } catch (e) {",
													"        const errorMsg = `Schema variable ${schemaJson} not found. Error: ${e.message}`;",
													"        pm.expect(false, errorMsg).to.be.true;",
													"        console.error(errorMsg);",
													"    }",
													"}",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Request",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Request Method Validation\", () => pm.expect(pm.request.method).to.eql(\"POST\"));",
													"",
													"pm.test(\"Base URL Validation\", () => pm.expect(baseUrl).to.not.be.undefined);",
													"",
													"pm.test(\"Authorization Header Validation\", () =>",
													"    pm.expect(authorizationHeader, \"Authorization header must start with 'Bearer'\").to.match(/^Bearer /)",
													");",
													"",
													"pm.test(\"Request URL Validation\", () => pm.expect(pm.request.url.toString()).to.eql(expectedUrl));",
													"",
													"pm.test(\"Request Body Validation\", () => pm.expect(requestBody).to.not.be.null);",
													"",
													"pm.test(\"Request Body Schema Validation\", () => validateSchema(requestSchema, requestBody));",
													"",
													"// --------------------------------------------------------------------------------",
													"// Tests for the Response",
													"// --------------------------------------------------------------------------------",
													"",
													"pm.test(\"Response Status Code Validation\", () => pm.response.to.have.status(401));",
													"    ",
													"pm.test(\"Response Content-Type Validation\", () =>",
													"    pm.response.to.have.header(\"Content-Type\", \"application/json; charset=UTF-8\")",
													");",
													"",
													"pm.test(\"Response Body Validation\", () => {",
													"    try {",
													"        validateResponseBody(responseBody);",
													"    } catch (e) {",
													"        console.error(\"Could not parse the response body as JSON. Error: \" + e.message, e.stack);",
													"        console.error(\"Raw response body:\", pm.response.body);",
													"        pm.expect(false, `Response body is not valid JSON. Error: ${e.message}`).to.be.true;",
													"    }",
													"});",
													"",
													"pm.test(\"Response should have correct error message\", () => {",
													"    const expectedResponse = { error: \"Invalid token.\" };",
													"    pm.expect(responseBody).to.eql(expectedResponse);",
													"});",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "akdmakdnasndandsaaadwefdwefwcwevw",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\n  \"@type\": \"Appointment\",\n  \"category\": \"New Install Order\",\n  \"description\": \"Support new install Order for a customer\",\n  \"validFor\": {\n    \"startDateTime\": \"{{firstAvailableStartDateTime}}\",\n    \"endDateTime\": \"{{firstAvailableEndDateTime}}\"\n  },\n  \"externalId\": [\n    {\n      \"@type\": \"ExternalIdentifier\",\n      \"owner\": \"ProjectManagementPlatform\",\n      \"externalIdentifierType\": \"ProjectReferenceId\",\n      \"id\": \"\"\n    }\n  ],\n  \"relatedEntity\": [\n    {\n      \"role\": \"Product\",\n      \"@type\": \"RelatedEntity\",\n      \"entity\": {\n        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",\n        \"name\": \"ftthl2r\",\n        \"@type\": \"EntityRef\",\n        \"@referredType\": \"ProductRef\"\n      }\n    }\n  ],\n  \"relatedParty\": [\n    {\n      \"role\": \"buyer\",\n      \"@type\": \"RelatedPartyRefOrPartyRoleRef\",\n      \"partyOrPartyRole\": {\n        \"id\": \"TEST\",\n        \"name\": \"TEST\",\n        \"@type\": \"PartyRef\",\n        \"@referredType\": \"Organisation\"\n      }\n    }\n  ],\n  \"appointmentType\": \"order\",\n  \"ispMigration\": false,\n  \"reappointment\": false,\n  \"relatedPlace\": {\n    \"role\": \"install location\",\n    \"@type\": \"RelatedPlaceRef\",\n    \"place\": {\n      \"id\": \"701000311059\",\n      \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",\n      \"name\": \"end user's address\",\n      \"externalIdentifier\": [\n        {\n          \"id\": \"701000311059\",\n          \"externalIdentifierType\": \"UPRN\",\n          \"@type\": \"ExternalIdentifier\"\n        }\n      ],\n      \"@type\": \"PlaceRef\",\n      \"@referredType\": \"GeographicAddress\"\n    }\n  }\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{baseUrl}}/tmf-api/v5/appointmentManagement/v1/appointment?Fields=id,name",
											"host": [
												"{{baseUrl}}"
											],
											"path": [
												"tmf-api",
												"v5",
												"appointmentManagement",
												"v1",
												"appointment"
											],
											"query": [
												{
													"key": "Fields",
													"value": "id,name",
													"description": "Comma-separated properties to be provided in response"
												}
											]
										}
									},
									"response": []
								}
							]
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"currentDate =new Date();",
									"",
									"// Send the SearchTimeSlot request",
									"pm.sendRequest({",
									"    url: pm.environment.get(\"baseUrl\") + \"/tmf-api/v5/appointmentManagement/v1/searchTimeSlot?Fields=id,name\",",
									"    method: 'POST',",
									"    header: {",
									"        'Content-Type': 'application/json',",
									"        'Authorization': 'Bearer ' + pm.environment.get(\"accessToken\")",
									"    },",
									"    body: {",
									"        mode: 'raw',",
									"        raw: {",
									"                \"@type\": \"SearchTimeSlot\",",
									"                \"requestedTimeSlot\": [",
									"                    {",
									"                    \"validFor\": {",
									"                        \"startDateTime\": currentDate.toISOString()",
									"                    },",
									"                    \"@type\": \"TimeSlot\"",
									"                    }",
									"                ],",
									"                \"relatedParty\": {",
									"                    \"role\": \"buyer\",",
									"                    \"@type\": \"RelatedPartyRefOrPartyRoleRef\",",
									"                    \"partyOrPartyRole\": {",
									"                    \"id\": \"TEST\",",
									"                    \"name\": \"TEST\",",
									"                    \"@type\": \"PartyRef\",",
									"                    \"@referredType\": \"Organisation\"",
									"                    }",
									"                },",
									"                \"appointmentType\": \"order\",",
									"                \"ispMigration\": false,",
									"                \"reappointment\": false,",
									"                \"relatedPlace\": {",
									"                    \"role\": \"install location\",",
									"                    \"@type\": \"RelatedPlaceRef\",",
									"                    \"place\": {",
									"                    \"id\": \"701000311059\",",
									"                    \"href\": \"https://api.stg.cityfibre.com/tmf-api/v5/geographicAddress/v1/geographicAddress/5880000020\",",
									"                    \"name\": \"end user's address\",",
									"                    \"externalIdentifier\": [",
									"                        {",
									"                        \"id\": \"701000311059\",",
									"                        \"externalIdentifierType\": \"UPRN\",",
									"                        \"@type\": \"ExternalIdentifier\"",
									"                        }",
									"                    ],",
									"                    \"@type\": \"PlaceRef\",",
									"                    \"@referredType\": \"GeographicAddress\"",
									"                    }",
									"                },",
									"                \"relatedEntity\": [",
									"                    {",
									"                    \"role\": \"Product\",",
									"                    \"@type\": \"RelatedEntity\",",
									"                    \"entity\": {",
									"                        \"id\": \"8fd5751e-c6aa-4b05-8cb9-da28843ee157\",",
									"                        \"name\": \"ftthl2r\",",
									"                        \"@type\": \"EntityRef\",",
									"                        \"@referredType\": \"ProductRef\"",
									"                    }",
									"                    }",
									"                ]",
									"            }",
									"    }",
									"}, function (err, res) {",
									"    if (err) {",
									"        console.error(\"Error sending SearchTimeSlot request:\", err);",
									"        return;",
									"    }",
									"    ",
									"    // Parse the response body",
									"    const responseBody = res.json();",
									"    ",
									"    // Capture the startDateTime and endDateTime from availableTimeSlot",
									"    const availableTimeSlots = responseBody.availableTimeSlot;",
									"    if (availableTimeSlots && availableTimeSlots.length > 0) {",
									"        const firstAvailableSlot = availableTimeSlots[0].validFor;",
									"        pm.environment.set(\"firstAvailableStartDateTime\", firstAvailableSlot.startDateTime);",
									"        pm.environment.set(\"firstAvailableEndDateTime\", firstAvailableSlot.endDateTime);",
									"        ",
									"        // Log for debugging",
									"        console.log(\"First Available Start DateTime:\", firstAvailableSlot.startDateTime);",
									"        console.log(\"First Available End DateTime:\", firstAvailableSlot.endDateTime);",
									"    } else {",
									"        console.warn(\"No available time slots found in the response.\");",
									"    }",
									"});"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						}
					]
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"// Get the current date and time\r",
							"const currentDateTime = new Date().toISOString();\r",
							"\r",
							"// Set the current date and time as an environment variable\r",
							"pm.environment.set(\"currentStartDateTime\", currentDateTime);\r",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"auth": {
		"type": "bearer",
		"bearer": [
			{
				"key": "token",
				"value": "{{accessToken}}",
				"type": "string"
			}
		]
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					"// --------------------------------------------------------------------------------\r",
					"// Variables\r",
					"// --------------------------------------------------------------------------------\r",
					"\r",
					"const currentTime = Math.floor(Date.now() / 1000);\r",
					"const tokenExpiration = pm.environment.get(\"tokenExpiration\");\r",
					"\r",
					"// --------------------------------------------------------------------------------\r",
					"// Script\r",
					"// --------------------------------------------------------------------------------\r",
					"\r",
					"if (!tokenExpiration || currentTime >= tokenExpiration) {\r",
					"\r",
					"    pm.sendRequest({\r",
					"        url: `${pm.environment.get(\"authUrl\")}/oauth/token`,\r",
					"        method: 'POST',\r",
					"        header: {\r",
					"            'Content-Type': 'application/json'\r",
					"        },\r",
					"        body: {\r",
					"            mode: 'raw',\r",
					"            raw: {\r",
					"                'client_id': `${pm.environment.get(\"clientId\")}`,\r",
					"                'client_secret': `${pm.environment.get(\"clientSecret\")}`,\r",
					"                'audience': `${pm.environment.get(\"audience\")}`,\r",
					"                'grant_type': `${pm.environment.get(\"grantType\")}`\r",
					"            }\r",
					"        },\r",
					"\r",
					"    }, function (error, response) {\r",
					"        if (error) {\r",
					"            console.log(\"Error refreshing token: \", error);\r",
					"            return;\r",
					"        }\r",
					"\r",
					"        const responseBody = response.json();\r",
					"        const accessToken = responseBody.access_token;\r",
					"        const expiresIn = responseBody.expires_in;\r",
					"        const expirationTimestamp = currentTime + expiresIn;\r",
					"        console.log(responseBody)\r",
					"\r",
					"        pm.environment.set(\"accessToken\", accessToken);\r",
					"        pm.environment.set(\"tokenExpiration\", expirationTimestamp);\r",
					"    });\r",
					"}"
				]
			}
		}
	],
	"variable": [
		{
			"key": "requestSchemaSearchTimeSlot",
			"value": "{\"type\":\"object\",\"properties\":{\"@type\":{\"type\":\"string\"},\"requestedTimeSlot\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"validFor\":{\"type\":\"object\",\"properties\":{\"startDateTime\":{\"type\":\"string\"}},\"required\":[\"startDateTime\"]},\"@type\":{\"type\":\"string\"}},\"required\":[\"validFor\",\"@type\"]}]},\"relatedParty\":{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"partyOrPartyRole\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"partyOrPartyRole\"]},\"appointmentType\":{\"type\":\"string\"},\"ispMigration\":{\"type\":\"boolean\"},\"reappointment\":{\"type\":\"boolean\"},\"relatedPlace\":{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"place\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"href\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"externalIdentifier\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"externalIdentifierType\":{\"type\":\"string\"}},\"required\":[\"id\",\"externalIdentifierType\"]}]},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"href\",\"name\",\"externalIdentifier\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"place\"]},\"relatedEntity\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"entity\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"entity\"]}]}},\"required\":[\"@type\",\"requestedTimeSlot\",\"relatedParty\",\"appointmentType\",\"ispMigration\",\"reappointment\",\"relatedPlace\",\"relatedEntity\"]}",
			"type": "string"
		},
		{
			"key": "responseSchemaSearchTimeSlot",
			"value": "{\"type\":\"object\",\"properties\":{\"@type\":{\"type\":\"string\"},\"relatedPlace\":{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"place\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"href\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"externalIdentifier\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"externalIdentifierType\":{\"type\":\"string\"}},\"required\":[\"id\",\"externalIdentifierType\"]}]},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"href\",\"name\",\"externalIdentifier\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"place\"]},\"searchResult\":{\"type\":\"string\"},\"relatedEntity\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"entity\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"entity\"]}]},\"searchDate\":{\"type\":\"string\"},\"requestedTimeSlot\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"validFor\":{\"type\":\"object\",\"properties\":{\"startDateTime\":{\"type\":\"string\"}},\"required\":[\"startDateTime\"]},\"@type\":{\"type\":\"string\"}},\"required\":[\"validFor\",\"@type\"]}]},\"availableTimeSlot\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"@type\":{\"type\":\"string\"},\"validFor\":{\"type\":\"object\",\"properties\":{\"startDateTime\":{\"type\":\"string\"},\"endDateTime\":{\"type\":\"string\"}},\"required\":[\"startDateTime\",\"endDateTime\"]}},\"required\":[\"@type\",\"validFor\"]}]}},\"required\":[\"@type\",\"relatedPlace\",\"searchResult\",\"relatedEntity\",\"searchDate\",\"requestedTimeSlot\",\"availableTimeSlot\"]}",
			"type": "string"
		},
		{
			"key": "requestSchemaAppointmentRequest",
			"value": "{\"type\":\"object\",\"properties\":{\"@type\":{\"type\":\"string\"},\"category\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"validFor\":{\"type\":\"object\",\"properties\":{\"startDateTime\":{\"type\":\"string\"},\"endDateTime\":{\"type\":\"string\"}},\"required\":[\"startDateTime\",\"endDateTime\"]},\"externalId\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"@type\":{\"type\":\"string\"},\"owner\":{\"type\":\"string\"},\"externalIdentifierType\":{\"type\":\"string\"},\"id\":{\"type\":\"string\"}},\"required\":[\"@type\",\"owner\",\"externalIdentifierType\",\"id\"]}]},\"relatedEntity\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"entity\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"entity\"]}]},\"relatedParty\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"partyOrPartyRole\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"partyOrPartyRole\"]}]},\"appointmentType\":{\"type\":\"string\"},\"ispMigration\":{\"type\":\"boolean\"},\"reappointment\":{\"type\":\"boolean\"},\"relatedPlace\":{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"place\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"href\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"externalIdentifier\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"externalIdentifierType\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"}},\"required\":[\"id\",\"externalIdentifierType\",\"@type\"]}]},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"href\",\"name\",\"externalIdentifier\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"place\"]}},\"required\":[\"@type\",\"category\",\"description\",\"validFor\",\"externalId\",\"relatedEntity\",\"relatedParty\",\"appointmentType\",\"ispMigration\",\"reappointment\",\"relatedPlace\"]}",
			"type": "string"
		},
		{
			"key": "responseSchemaAppointmentRequest",
			"value": "{\"type\":\"object\",\"properties\":{\"@type\":{\"type\":\"string\"},\"id\":{\"type\":\"string\"},\"relatedPlace\":{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"place\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"href\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"externalIdentifier\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"externalIdentifierType\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"}},\"required\":[\"id\",\"externalIdentifierType\",\"@type\"]}]},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"href\",\"name\",\"externalIdentifier\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"place\"]},\"appointmentType\":{\"type\":\"string\"},\"validFor\":{\"type\":\"object\",\"properties\":{\"startDateTime\":{\"type\":\"string\"},\"endDateTime\":{\"type\":\"string\"}},\"required\":[\"startDateTime\",\"endDateTime\"]},\"relatedEntity\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"entity\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"entity\"]}]},\"reappointment\":{\"type\":\"boolean\"},\"description\":{\"type\":\"string\"},\"externalId\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"@type\":{\"type\":\"string\"},\"owner\":{\"type\":\"string\"},\"externalIdentifierType\":{\"type\":\"string\"},\"id\":{\"type\":\"string\"}},\"required\":[\"@type\",\"owner\",\"externalIdentifierType\",\"id\"]}]},\"ispMigration\":{\"type\":\"boolean\"},\"creationDate\":{\"type\":\"string\"},\"relatedParty\":{\"type\":\"array\",\"items\":[{\"type\":\"object\",\"properties\":{\"role\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"partyOrPartyRole\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"},\"@referredType\":{\"type\":\"string\"}},\"required\":[\"id\",\"name\",\"@type\",\"@referredType\"]}},\"required\":[\"role\",\"@type\",\"partyOrPartyRole\"]}]},\"category\":{\"type\":\"string\"},\"status\":{\"type\":\"string\"}},\"required\":[\"@type\",\"id\",\"relatedPlace\",\"appointmentType\",\"validFor\",\"relatedEntity\",\"reappointment\",\"description\",\"externalId\",\"ispMigration\",\"creationDate\",\"relatedParty\",\"category\",\"status\"]}",
			"type": "string"
		},
		{
			"key": "responseSchemaBadRequest",
			"value": "{\"type\":\"object\",\"properties\":{\"code\":{\"type\":\"string\"},\"reason\":{\"type\":\"string\"},\"@type\":{\"type\":\"string\"}},\"required\":[\"code\",\"reason\",\"@type\"]}",
			"type": "string"
		}
	]
}